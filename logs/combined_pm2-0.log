2019-11-13T22:22:44: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" VARCHAR(255) NOT NULL , "username" VARCHAR(255) NOT NULL UNIQUE, "firstname" VARCHAR(255), "lastname" VARCHAR(255), "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) UNIQUE, "t1" BOOLEAN NOT NULL DEFAULT false, "t2" BOOLEAN NOT NULL DEFAULT false, "t3" BOOLEAN NOT NULL DEFAULT false, "is_admin" BOOLEAN NOT NULL DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:22:44: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:22:44: Executing (default): CREATE TABLE IF NOT EXISTS "leave" ("id" UUID NOT NULL , "user_id" VARCHAR(255) NOT NULL REFERENCES "Users" ("id") ON DELETE CASCADE ON UPDATE CASCADE, "date_from" DATE NOT NULL, "date_to" DATE NOT NULL, "reason" VARCHAR(1000) NOT NULL, "del_reason" VARCHAR(1000), "approver_id" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "status" BOOLEAN NOT NULL DEFAULT false, "date_approve" DATE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:22:44: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'leave' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:22:44: Executing (default): CREATE TABLE IF NOT EXISTS "psr" ("id" UUID NOT NULL , "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "psr_no"   SERIAL, "purchase_class" VARCHAR(255), "purchase_typ" VARCHAR(255), "purchase_just" VARCHAR(255), "cost_typ" VARCHAR(255), "date_req" DATE, "project_title" VARCHAR(255), "vessel_code" VARCHAR(255), "delv" VARCHAR(255), "psr_desc" JSON, "decline_reason" VARCHAR(255), "delete_req" BOOLEAN NOT NULL DEFAULT false, "status_t1_1" BOOLEAN NOT NULL DEFAULT false, "status_t1_2" BOOLEAN NOT NULL DEFAULT false, "status_t2" BOOLEAN NOT NULL DEFAULT false, "status_decline" BOOLEAN NOT NULL DEFAULT false, "create_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "del_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_1" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_2" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "approver_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "decline_user" VARCHAR(255), "date_pending_1" DATE, "date_pending_2" DATE, "date_approve" DATE, "date_decline" DATE, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:22:44: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'psr' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:22:44: Executing (default): CREATE TABLE IF NOT EXISTS "purchase_order" ("id" UUID NOT NULL , "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "po_no"   SERIAL, "po_ref" VARCHAR(255), "delv_due" DATE, "ship_mode" VARCHAR(255), "psr_no" VARCHAR(255) REFERENCES "psr" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "cca_no" VARCHAR(255), "pay_mode" VARCHAR(255), "address" VARCHAR(255), "po_desc" JSON, "cl_name" VARCHAR(255), "cl_company" VARCHAR(255), "decline_reason" VARCHAR(255), "delete_req" BOOLEAN NOT NULL DEFAULT false, "status_t1_1" BOOLEAN NOT NULL DEFAULT false, "status_t1_2" BOOLEAN NOT NULL DEFAULT false, "status_t2" BOOLEAN NOT NULL DEFAULT false, "status_decline" BOOLEAN NOT NULL DEFAULT false, "create_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "del_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_1" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_2" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "approver_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "decline_user" VARCHAR(255), "date_pending_1" DATE, "date_pending_2" DATE, "date_approve" DATE, "date_decline" DATE, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:22:44: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'purchase_order' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:22:44: Listening to port: 3000
2019-11-13T22:23:01: 2019-11-13T14:23:01.877Z [user] info: login
2019-11-13T22:23:01: 2019-11-13T14:23:01.879Z [Passport] info: Find User
2019-11-13T22:23:01: Executing (default): SELECT "id", "username", "firstname", "lastname", "password", "email", "t1", "t2", "t3", "is_admin", "createdAt", "updatedAt" FROM "Users" AS "Users" WHERE "Users"."username" = 'usert3';
2019-11-13T22:23:01: 2019-11-13T14:23:01.950Z [Passport] debug: Serialize User
2019-11-13T22:23:01: development
2019-11-13T22:23:01: 2019-11-13T14:23:01.951Z [user_login] debug: usert3
2019-11-13T22:23:01: [0mPOST /api/login [32m200 [0m93.087 ms - 327[0m
2019-11-13T22:24:45: Warning: connect.session() MemoryStore is not
designed for a production environment, as it will leak
memory, and will not scale past a single process.
2019-11-13T22:24:45: Executing (default): CREATE TABLE IF NOT EXISTS "Users" ("id" VARCHAR(255) NOT NULL , "username" VARCHAR(255) NOT NULL UNIQUE, "firstname" VARCHAR(255), "lastname" VARCHAR(255), "password" VARCHAR(255) NOT NULL, "email" VARCHAR(255) UNIQUE, "t1" BOOLEAN NOT NULL DEFAULT false, "t2" BOOLEAN NOT NULL DEFAULT false, "t3" BOOLEAN NOT NULL DEFAULT false, "is_admin" BOOLEAN NOT NULL DEFAULT false, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:24:45: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'Users' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:24:45: Executing (default): CREATE TABLE IF NOT EXISTS "leave" ("id" UUID NOT NULL , "user_id" VARCHAR(255) NOT NULL REFERENCES "Users" ("id") ON DELETE CASCADE ON UPDATE CASCADE, "date_from" DATE NOT NULL, "date_to" DATE NOT NULL, "reason" VARCHAR(1000) NOT NULL, "del_reason" VARCHAR(1000), "approver_id" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "status" BOOLEAN NOT NULL DEFAULT false, "date_approve" DATE, "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:24:45: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'leave' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:24:45: Executing (default): CREATE TABLE IF NOT EXISTS "psr" ("id" UUID NOT NULL , "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "psr_no"   SERIAL, "purchase_class" VARCHAR(255), "purchase_typ" VARCHAR(255), "purchase_just" VARCHAR(255), "cost_typ" VARCHAR(255), "date_req" DATE, "project_title" VARCHAR(255), "vessel_code" VARCHAR(255), "delv" VARCHAR(255), "psr_desc" JSON, "decline_reason" VARCHAR(255), "delete_req" BOOLEAN NOT NULL DEFAULT false, "status_t1_1" BOOLEAN NOT NULL DEFAULT false, "status_t1_2" BOOLEAN NOT NULL DEFAULT false, "status_t2" BOOLEAN NOT NULL DEFAULT false, "status_decline" BOOLEAN NOT NULL DEFAULT false, "create_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "del_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_1" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_2" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "approver_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "decline_user" VARCHAR(255), "date_pending_1" DATE, "date_pending_2" DATE, "date_approve" DATE, "date_decline" DATE, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:24:45: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'psr' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:24:45: Executing (default): CREATE TABLE IF NOT EXISTS "purchase_order" ("id" UUID NOT NULL , "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL, "po_no"   SERIAL, "po_ref" VARCHAR(255), "delv_due" DATE, "ship_mode" VARCHAR(255), "psr_no" VARCHAR(255) REFERENCES "psr" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "cca_no" VARCHAR(255), "pay_mode" VARCHAR(255), "address" VARCHAR(255), "po_desc" JSON, "cl_name" VARCHAR(255), "cl_company" VARCHAR(255), "decline_reason" VARCHAR(255), "delete_req" BOOLEAN NOT NULL DEFAULT false, "status_t1_1" BOOLEAN NOT NULL DEFAULT false, "status_t1_2" BOOLEAN NOT NULL DEFAULT false, "status_t2" BOOLEAN NOT NULL DEFAULT false, "status_decline" BOOLEAN NOT NULL DEFAULT false, "create_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "del_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_1" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "t2_user_2" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "approver_user" VARCHAR(255) REFERENCES "Users" ("id") ON DELETE SET NULL ON UPDATE CASCADE, "decline_user" VARCHAR(255), "date_pending_1" DATE, "date_pending_2" DATE, "date_approve" DATE, "date_decline" DATE, "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id"));
2019-11-13T22:24:45: Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'purchase_order' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
2019-11-13T22:24:45: Listening to port: 3000
2019-11-13T22:24:52: 2019-11-13T14:24:52.531Z [user] info: login
2019-11-13T22:24:52: 2019-11-13T14:24:52.533Z [Passport] info: Find User
2019-11-13T22:24:52: Executing (default): SELECT "id", "username", "firstname", "lastname", "password", "email", "t1", "t2", "t3", "is_admin", "createdAt", "updatedAt" FROM "Users" AS "Users" WHERE "Users"."username" = 'usert3';
2019-11-13T22:24:52: 2019-11-13T14:24:52.576Z [Passport] debug: Serialize User
2019-11-13T22:24:52: production
2019-11-13T22:24:52: [0mPOST /api/login [32m200 [0m76.039 ms - 327[0m
2019-11-13T22:27:11: 2019-11-13T14:27:11.478Z [Passport] info: Deserialize User - Start
2019-11-13T22:27:11: Executing (default): SELECT "id", "username", "firstname", "lastname", "password", "email", "t1", "t2", "t3", "is_admin", "createdAt", "updatedAt" FROM "Users" AS "Users" WHERE "Users"."id" = '21d2dc32-e99c-40c6-9143-32b02b93e7cd';
2019-11-13T22:27:11: 2019-11-13T14:27:11.636Z [Passport] debug: Deserialize User - Done
2019-11-13T22:27:11: 2019-11-13T14:27:11.637Z [Authenticate] info: LoggedIn
2019-11-13T22:27:11: 2019-11-13T14:27:11.637Z [psr] info: show_psr_page
2019-11-13T22:27:11: Executing (default): SELECT count(*) AS "count" FROM "psr" AS "psr";
2019-11-13T22:27:11: Executing (default): SELECT "psr"."id", "psr"."createdAt", "psr"."psr_no", "psr"."purchase_class", "psr"."purchase_typ", "psr"."purchase_just", "psr"."cost_typ", "psr"."date_req", "psr"."project_title", "psr"."vessel_code", "psr"."delv", "psr"."psr_desc", "psr"."decline_reason", "psr"."delete_req", "psr"."status_t1_1", "psr"."status_t1_2", "psr"."status_t2", "psr"."status_decline", "psr"."create_user", "psr"."del_user", "psr"."t2_user_1", "psr"."t2_user_2", "psr"."approver_user", "psr"."decline_user", "psr"."date_pending_1", "psr"."date_pending_2", "psr"."date_approve", "psr"."date_decline", "psr"."updatedAt", "create_user_psr"."id" AS "create_user_psr.id", "create_user_psr"."username" AS "create_user_psr.username", "create_user_psr"."firstname" AS "create_user_psr.firstname", "create_user_psr"."lastname" AS "create_user_psr.lastname", "t2_user_psr"."id" AS "t2_user_psr.id", "t2_user_psr"."username" AS "t2_user_psr.username", "t2_user_psr"."firstname" AS "t2_user_psr.firstname", "t2_user_psr"."lastname" AS "t2_user_psr.lastname", "t2_user2_psr"."id" AS "t2_user2_psr.id", "t2_user2_psr"."username" AS "t2_user2_psr.username", "t2_user2_psr"."firstname" AS "t2_user2_psr.firstname", "t2_user2_psr"."lastname" AS "t2_user2_psr.lastname", "approver_psr"."id" AS "approver_psr.id", "approver_psr"."username" AS "approver_psr.username", "approver_psr"."firstname" AS "approver_psr.firstname", "approver_psr"."lastname" AS "approver_psr.lastname", "del_req_user_psr"."id" AS "del_req_user_psr.id", "del_req_user_psr"."username" AS "del_req_user_psr.username", "del_req_user_psr"."firstname" AS "del_req_user_psr.firstname", "del_req_user_psr"."lastname" AS "del_req_user_psr.lastname" FROM "psr" AS "psr" INNER JOIN "Users" AS "create_user_psr" ON "psr"."create_user" = "create_user_psr"."id" LEFT OUTER JOIN "Users" AS "t2_user_psr" ON "psr"."t2_user_1" = "t2_user_psr"."id" LEFT OUTER JOIN "Users" AS "t2_user2_psr" ON "psr"."t2_user_2" = "t2_user2_psr"."id" LEFT OUTER JOIN "Users" AS "approver_psr" ON "psr"."approver_user" = "approver_psr"."id" LEFT OUTER JOIN "Users" AS "del_req_user_psr" ON "psr"."del_user" = "del_req_user_psr"."id" ORDER BY "psr"."createdAt" DESC LIMIT 10 OFFSET 0;
2019-11-13T22:27:11: [0mGET /api/psr/all/1 [32m200 [0m190.937 ms - 926[0m
